// Andrew Id: mngongng
// Author: Mathias Ngwa Ngong Ngai

// Importing the header file
#include "NetworkVulnerability.h"

int main()
{

	Graph AritPtGraph(4); // graph to use in finding the Ap
	//-----------------------------------before reading
	// Start variable decleration
	int testcasecounter = 0;
	int e1, n1, nvertices, toPrintCaseNo;
	toPrintCaseNo = 1; // for printing the test case number
	auto start = chrono::high_resolution_clock::now();//to keep track of the runtime
	// in and output file variable creation
	char inputPath[1024], outputPath[1024];
	//getting the input from the user
	sprintf(inputPath, "%s", "input.txt");
	sprintf(outputPath, "%s", "output.txt");
	// opening input file for reading
	FILE *inFileStream = fopen(inputPath, "r");
	if (!inFileStream) // print error message if file path is wrong or for some reason the file cannot open
	{
		char message[1024];
		sprintf(message, "Cannot open input file for reading: %s", inputPath);
		throw std::ios_base::failure(message);
	}
	// opening out put file for writing
	FILE *outFileStream = fopen(outputPath, "w");
	if (!outFileStream)
	{
		char message[1024];
		sprintf(message, "Cannot open output file for writing: %s", outputPath);
		throw std::ios_base::failure(message);
	}
	else
	{
		// cout << "opened the output file";
		fprintf(outFileStream, "mngongng\n");
	}
	map<int, int> holdTingz;
	while (!feof(inFileStream))//iterate through line sof the input file till end of file
	{

		if (!feof(inFileStream))
		{ // Variable declaration

			char input1[255];
			int v1, v2;


			fgets(input1, 255, inFileStream); // reading the lines

			if (input1[0] == '\n')//skip empty lines
			{
				continue;
			}
			std::string s = input1;
			char a[20];
			strcpy(a, s.c_str()); // strcpy uses token varable to extract data using space as delimiter
			char *token = strtok(a, " ");
			v1 = atoi(token);
			token = strtok(NULL, " ");
			v2 = atoi(token);
			n1 = v1;
			e1 = v2;
			if (n1 == 0 && e1 == 0)
			{
				break;
			}

			if (testcasecounter == 0) // if the counter is 0 then it is the begining of the a new test case
									  // so set set counter to the new number of vertices and decrement for each line of that test case
									  // thus resize the grapgh and the adjecency list for ti use for the finding edges and articulation ponts
			{
				testcasecounter = e1;
				bridgeAlist.resize(n1);
				AritPtGraph.rsize(n1);
				nvertices = n1;
			}
			else // else if counter is not 0 then we are reading the edges and pussing back of the adjecency list or adding the edge to the graph
			{
				testcasecounter--; // decrementing the counter to keep track of test cases

				bridgeAlist[v1 - 1].push_back(v2 - 1);
				bridgeAlist[v2 - 1].push_back(v1 - 1);
				//-----ap
				AritPtGraph.addEdge(v1, v2);
				//-----
			}

			if (testcasecounter == 0) // if testcasecounter is 0 means done reading the edges so we should print the results
									  // and clear all the useful variables for next test case
			{
				// put from map to grap here in for loop
				map<int, int>::iterator itr;

				fprintf(outFileStream, "Test case: ");
				fprintf(outFileStream, "%d", toPrintCaseNo);
				fprintf(outFileStream, "\n");
				toPrintCaseNo++;
				//

				//------ap

				if (AritPtGraph.AP() == "") // if there is no Articulation point returned from the function, print none
				{
					fprintf(outFileStream, "Articulation points: None ");
					fprintf(outFileStream, "\n");
				}
				else // else if the is a string returned print the values to the file
				{
					// cout << "\n Articulation points :", AritPtGraph.AP();
					fprintf(outFileStream, "Articulation points:%s ", AritPtGraph.AP().c_str());
					fprintf(outFileStream, "\n");
					// cout << endl;
				}
				vector<pair<int, int>> bridges;

				findBridges(bridges);					  // puttting the bridges in the the vector for printing
				fprintf(outFileStream, "Bridge edges: "); // printing to file
				// cout << "Bridge edges :";
				bool xf = false;
				map<int, int> BToPrint;
				for (auto x : bridges) // looping through the gridges vector to get the pairs of bridges
				{
					xf = true;
					// cout << "(" << x.first << ", " << x.second << "), "; //printing the bridegs
					if (x.first < x.second)
					{
						// fprintf(outFileStream, "(%d, ", x.first);
						// fprintf(outFileStream, "%d) ", x.second);
						BToPrint.insert({x.first, x.second});
					}
					else
					{
						// fprintf(outFileStream, "(%d, ", x.second);
						// fprintf(outFileStream, "%d) ", x.first);
						BToPrint.insert({x.second, x.first});
					}
				}

				// map<int, int>::iterator itr;
				for (itr = BToPrint.begin(); itr != BToPrint.end(); itr++)
				{
					fprintf(outFileStream, "(%d, ", itr->first);
					fprintf(outFileStream, "%d) ", itr->second);
					// cout << "(" << itr->first << ", " << itr->second << "), "; //printing the bridegs
				}

				if (xf == 0)
				{
					fprintf(outFileStream, "None ");
					// cout << "None";
				}
				// new line after printing None or After printing the bridges
				fprintf(outFileStream, "\n");
				fprintf(outFileStream, "\n");
				// deleting the vectors to allow for the next test case to run with empty things
				bridgeAlist.clear();
				LowVec.clear();
				tinVec.clear();
				VistedVertex.clear();
				holdTingz.clear();
			}
		}
	}

	fflush(outFileStream);

	fclose(outFileStream);

	fclose(inFileStream);
	return 0;
}