//header file for class definitions and importing libraries

using namespace std;
#include <bits/stdc++.h>
#include <iostream>
#include <list>
#include <iostream>
#include <fstream>
#include <limits.h>
#include <math.h>
#include <unistd.h>
#include <chrono>
#include <stdio.h>
#include <string.h>
#include <map>
#define NIL -1
//Variable decleration starts
//start variables fr bridge class
vector<pair<int, int>> bridges;
vector<vector<int>> bridgeAlist;//the graph for findingt the bridges
vector<bool> VistedVertex;
vector<int> LowVec;
vector<int> tinVec;
int timer = 0;
int timerhold;

//variable declaration ends

//Begin functions for finding brideges
//refrence for source of bridge code : https://blog.devgenius.io/bridges-and-articulation-points-in-an-undirected-graph-fe79347f0745
//Function for the Depth zFirst search
void dfs(int s, vector<pair<int, int>> &bridges, int p = -1)
{
	VistedVertex[s] = true;
    LowVec[s] =  timer++;
    tinVec[s] = LowVec[s];
for (auto x : bridgeAlist[s])
	{
		if (x == p){
			continue; 
        }
		if (VistedVertex[x]){ 
			LowVec[s] = min(LowVec[s], tinVec[x]); 
            }else{
			dfs(x, bridges, s);
			LowVec[s] = min(LowVec[s], LowVec[x]);
            if (LowVec[x] > tinVec[s])
			{
				bridges.push_back({s + 1, x + 1});
			}
		}
	}
}
//end depth first search function

//start function to serach for bridges
void findBridges(vector<pair<int, int>> &bridges)
{
	int n = bridgeAlist.size();
	VistedVertex.resize(n, false);
    tinVec.resize(n, -1);
	LowVec.resize(n, -1);
	

	int ccnter= 0;
	while(ccnter<n)//traversing the vector of pairs
	{
		if (!VistedVertex[ccnter])
        {
			dfs(ccnter, bridges);
        }
			ccnter++;
	}
}

//end functions for the brideges

//Start Articulation point undirected graph class
//refrence for sources : 
class Graph
{public://defining the public variables
    int vap;//variable for keeping track of the number of vertices
    list<int> *adj;//pointer array of lists
    Graph(int vap);	//default constructor
    void addEdge(int vap, int w);//adding to the grapgh
    void APUtil(int vap, bool visitedap[], int discap[], int lowap[],int parentap[], bool apap[]);
    void rsize(int vap);//resizing the graph for use in diffferent test cases
    string AP();//for returning AP as concatenated string
  
}; 
Graph::Graph(int vap)//constructor
{
	this->vap = vap;
	adj = new list<int>[vap];
}

void Graph::addEdge(int vap, int w)//adding new edges
{
	adj[--vap].push_back(--w);
	adj[w].push_back(vap);
}
void Graph::APUtil(int uap, bool visitedap[], int discap[],int lowap[], int parentap[], bool apap[])
{
	static int time = 0;
	visitedap[uap] = true;
	discap[uap] = lowap[uap] = ++time;
	list<int>::iterator i;
    int children = 0;
	for (i = adj[uap].begin(); i != adj[uap].end(); ++i)
	{
		int vap = *i;
		if (!visitedap[vap])
		{
		
			parentap[vap] = uap;
			APUtil(vap, visitedap, discap, lowap, parentap, apap);
				children++;
			lowap[uap] = min(lowap[uap], lowap[vap]);
				if (parentap[uap] == NIL && children > 1)
				apap[uap] = true;
					if (parentap[uap] != NIL && lowap[vap] >= discap[uap])
				apap[uap] = true;
		}else if(vap != parentap[uap]){
			lowap[uap] = min(lowap[uap], discap[vap]);
			}
		}
}
//fuction to concatenate the and return the Articulation points
string Graph::AP()
{
	int *discap = new int[vap];
	int *lowap = new int[vap];
	bool *visitedap = new bool[vap];
	bool *apap = new bool[vap];
	int *parentap = new int[vap];
	//setting the arrays to false to indicate as not visted
	for (int i = 0; i < vap; i++)
	{
		parentap[i] = NIL;
		visitedap[i] = false;
		apap[i] = false;
	}
	for (int i = 0; i < vap; i++){
		if (visitedap[i] == false){
			APUtil(i, visitedap, discap, lowap, parentap, apap);
		}
		}

	string forPrint = "";
		for (int i = 0; i < vap; i++)
	{
		if (apap[i] == true)
		{
			// cout << i + 1 << " ";
			forPrint = forPrint + " " + to_string(i + 1);
		}
	}

	return forPrint;
}

void Graph::rsize(int vap)//resizing to use for each yeast case
{
	this->vap = vap;
	adj = new list<int>[vap];
}
